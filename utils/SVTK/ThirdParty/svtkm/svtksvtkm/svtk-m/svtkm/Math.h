//============================================================================
//  Copyright (c) Kitware, Inc.
//  All rights reserved.
//  See LICENSE.txt for details.
//
//  This software is distributed WITHOUT ANY WARRANTY; without even
//  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//  PURPOSE.  See the above copyright notice for more information.
//============================================================================
// **** DO NOT EDIT THIS FILE!!! ****
// This file is automatically generated by Math.h.in

#ifndef svtk_m_Math_h
#define svtk_m_Math_h

#include <svtkm/TypeTraits.h>
#include <svtkm/Types.h>
#include <svtkm/VecTraits.h>

#ifndef SVTKM_CUDA
#include <cmath>
#include <limits.h>
#include <math.h>
#include <stdlib.h>
#endif // !SVTKM_CUDA

#if !defined(SVTKM_CUDA_DEVICE_PASS)
#define SVTKM_USE_STL
#include <algorithm>
#endif

#ifdef SVTKM_MSVC
#include <intrin.h>                // For bitwise intrinsics (__popcnt, etc)
#include <svtkm/internal/Windows.h> // for types used by MSVC intrinsics.
#ifndef SVTKM_CUDA
#include <math.h>
#endif // SVTKM_CUDA
#endif // SVTKM_MSVC

#define SVTKM_CUDA_MATH_FUNCTION_32(func) func##f
#define SVTKM_CUDA_MATH_FUNCTION_64(func) func

// clang-format off
namespace svtkm
{

//-----------------------------------------------------------------------------
namespace detail
{
template <typename T>
struct FloatingPointReturnType
{
  using ctype = typename svtkm::VecTraits<T>::ComponentType;
  using representable_as_float_type = std::integral_constant<bool,
                      ((sizeof(ctype) < sizeof(float)) || std::is_same<ctype, svtkm::Float32>::value)>;
  using Type = typename std::conditional<representable_as_float_type::value,
                                         svtkm::Float32,
                                         svtkm::Float64>::type;
};
} // namespace detail

/// Returns the constant 2 times Pi in float32.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float32 TwoPif()
{
  return 6.28318530717958647692528676655900576f;
}

/// Returns the constant Pi in float32.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float32 Pif()
{
  return 3.14159265358979323846264338327950288f;
}

/// Returns the constant Pi halves in float32.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float32 Pi_2f()
{
  return 1.57079632679489661923132169163975144f;
}

/// Returns the constant Pi thirds in float32.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float32 Pi_3f()
{
  return 1.04719755119659774615421446109316762f;
}

/// Returns the constant Pi fourths in float32.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float32 Pi_4f()
{
  return 0.78539816339744830961566084581987572f;
}

/// Returns the constant Pi one hundred and eightieth in float32.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float32 Pi_180f()
{
  return 0.01745329251994329547437168059786927f;
}

/// Returns the constant 2 times Pi in float64.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float64 TwoPi()
{
  return 6.28318530717958647692528676655900576;
}

/// Returns the constant Pi in float64.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float64 Pi()
{
  return 3.14159265358979323846264338327950288;
}

/// Returns the constant Pi halves in float64.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float64 Pi_2()
{
  return 1.57079632679489661923132169163975144;
}

/// Returns the constant Pi thirds in float64.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float64 Pi_3()
{
  return 1.04719755119659774615421446109316762;
}

/// Returns the constant Pi fourths in float64.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float64 Pi_4()
{
  return 0.78539816339744830961566084581987572;
}

/// Returns the constant Pi one hundred and eightieth in float64.
///
static constexpr inline SVTKM_EXEC_CONT svtkm::Float64 Pi_180()
{
  return 0.01745329251994329547437168059786927;
}

/// Returns the constant 2 times Pi.
///
template <typename T>
  static constexpr inline SVTKM_EXEC_CONT auto TwoPi() -> typename detail::FloatingPointReturnType<T>::Type
  {
    using FT = typename detail::FloatingPointReturnType<T>::Type;
    using RAFT = typename detail::FloatingPointReturnType<T>::representable_as_float_type;
    return static_cast<FT>(RAFT::value ? TwoPif() : TwoPi());
  }

/// Returns the constant Pi.
///
template <typename T>
  static constexpr inline SVTKM_EXEC_CONT auto Pi() -> typename detail::FloatingPointReturnType<T>::Type
  {
    using FT = typename detail::FloatingPointReturnType<T>::Type;
    using RAFT = typename detail::FloatingPointReturnType<T>::representable_as_float_type;
    return static_cast<FT>(RAFT::value ? Pif() : Pi());
  }

/// Returns the constant Pi halves.
///
template <typename T>
  static constexpr inline SVTKM_EXEC_CONT auto Pi_2() -> typename detail::FloatingPointReturnType<T>::Type
  {
    using FT = typename detail::FloatingPointReturnType<T>::Type;
    using RAFT = typename detail::FloatingPointReturnType<T>::representable_as_float_type;
    return static_cast<FT>(RAFT::value ? Pi_2f() : Pi_2());
  }

/// Returns the constant Pi thirds.
///
template <typename T>
  static constexpr inline SVTKM_EXEC_CONT auto Pi_3() -> typename detail::FloatingPointReturnType<T>::Type
  {
    using FT = typename detail::FloatingPointReturnType<T>::Type;
    using RAFT = typename detail::FloatingPointReturnType<T>::representable_as_float_type;
    return static_cast<FT>(RAFT::value ? Pi_3f() : Pi_3());
  }

/// Returns the constant Pi fourths.
///
template <typename T>
  static constexpr inline SVTKM_EXEC_CONT auto Pi_4() -> typename detail::FloatingPointReturnType<T>::Type
  {
    using FT = typename detail::FloatingPointReturnType<T>::Type;
    using RAFT = typename detail::FloatingPointReturnType<T>::representable_as_float_type;
    return static_cast<FT>(RAFT::value ? Pi_4f() : Pi_4());
  }
/// Returns the constant Pi one hundred and eightieth.
///
template <typename T>
  static constexpr inline SVTKM_EXEC_CONT auto Pi_180() -> typename detail::FloatingPointReturnType<T>::Type
  {
    using FT = typename detail::FloatingPointReturnType<T>::Type;
    using RAFT = typename detail::FloatingPointReturnType<T>::representable_as_float_type;
    return static_cast<FT>(RAFT::value ? Pi_180f() : Pi_180());
  }

/// Compute the sine of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Sin(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(sin)(x);
#else
  return std::sin(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Sin(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(sin)(x);
#else
  return std::sin(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Sin(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Sin(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Sin(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Sin(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Sin(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Sin(x[0]), svtkm::Sin(x[1]), svtkm::Sin(x[2]), svtkm::Sin(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Sin(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Sin(x[0]), svtkm::Sin(x[1]), svtkm::Sin(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Sin(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Sin(x[0]),
                                                                         svtkm::Sin(x[1]));
}

/// Compute the cosine of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Cos(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(cos)(x);
#else
  return std::cos(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Cos(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(cos)(x);
#else
  return std::cos(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Cos(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Cos(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Cos(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Cos(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Cos(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Cos(x[0]), svtkm::Cos(x[1]), svtkm::Cos(x[2]), svtkm::Cos(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Cos(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Cos(x[0]), svtkm::Cos(x[1]), svtkm::Cos(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Cos(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Cos(x[0]),
                                                                         svtkm::Cos(x[1]));
}

/// Compute the tangent of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Tan(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(tan)(x);
#else
  return std::tan(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Tan(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(tan)(x);
#else
  return std::tan(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Tan(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Tan(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Tan(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Tan(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Tan(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Tan(x[0]), svtkm::Tan(x[1]), svtkm::Tan(x[2]), svtkm::Tan(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Tan(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Tan(x[0]), svtkm::Tan(x[1]), svtkm::Tan(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Tan(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Tan(x[0]),
                                                                         svtkm::Tan(x[1]));
}

/// Compute the arc sine of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 ASin(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(asin)(x);
#else
  return std::asin(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 ASin(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(asin)(x);
#else
  return std::asin(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type ASin(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::ASin(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> ASin(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::ASin(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> ASin(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::ASin(x[0]), svtkm::ASin(x[1]), svtkm::ASin(x[2]), svtkm::ASin(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> ASin(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::ASin(x[0]), svtkm::ASin(x[1]), svtkm::ASin(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> ASin(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::ASin(x[0]),
                                                                         svtkm::ASin(x[1]));
}

/// Compute the arc cosine of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 ACos(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(acos)(x);
#else
  return std::acos(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 ACos(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(acos)(x);
#else
  return std::acos(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type ACos(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::ACos(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> ACos(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::ACos(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> ACos(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::ACos(x[0]), svtkm::ACos(x[1]), svtkm::ACos(x[2]), svtkm::ACos(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> ACos(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::ACos(x[0]), svtkm::ACos(x[1]), svtkm::ACos(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> ACos(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::ACos(x[0]),
                                                                         svtkm::ACos(x[1]));
}

/// Compute the arc tangent of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 ATan(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(atan)(x);
#else
  return std::atan(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 ATan(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(atan)(x);
#else
  return std::atan(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type ATan(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::ATan(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> ATan(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::ATan(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> ATan(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::ATan(x[0]), svtkm::ATan(x[1]), svtkm::ATan(x[2]), svtkm::ATan(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> ATan(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::ATan(x[0]), svtkm::ATan(x[1]), svtkm::ATan(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> ATan(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::ATan(x[0]),
                                                                         svtkm::ATan(x[1]));
}

/// Compute the arc tangent of \p x / \p y using the signs of both arguments
/// to determine the quadrant of the return value.
///
static inline SVTKM_EXEC_CONT svtkm::Float32 ATan2(svtkm::Float32 x, svtkm::Float32 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(atan2)(x, y);
#else
  return std::atan2(x, y);
#endif
}
static inline SVTKM_EXEC_CONT svtkm::Float64 ATan2(svtkm::Float64 x, svtkm::Float64 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(atan2)(x, y);
#else
  return std::atan2(x, y);
#endif
}

/// Compute the hyperbolic sine of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 SinH(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(sinh)(x);
#else
  return std::sinh(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 SinH(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(sinh)(x);
#else
  return std::sinh(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type SinH(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::SinH(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> SinH(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::SinH(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> SinH(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::SinH(x[0]), svtkm::SinH(x[1]), svtkm::SinH(x[2]), svtkm::SinH(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> SinH(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::SinH(x[0]), svtkm::SinH(x[1]), svtkm::SinH(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> SinH(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::SinH(x[0]),
                                                                         svtkm::SinH(x[1]));
}

/// Compute the hyperbolic cosine of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 CosH(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(cosh)(x);
#else
  return std::cosh(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 CosH(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(cosh)(x);
#else
  return std::cosh(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type CosH(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::CosH(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> CosH(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::CosH(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> CosH(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::CosH(x[0]), svtkm::CosH(x[1]), svtkm::CosH(x[2]), svtkm::CosH(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> CosH(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::CosH(x[0]), svtkm::CosH(x[1]), svtkm::CosH(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> CosH(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::CosH(x[0]),
                                                                         svtkm::CosH(x[1]));
}

/// Compute the hyperbolic tangent of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 TanH(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(tanh)(x);
#else
  return std::tanh(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 TanH(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(tanh)(x);
#else
  return std::tanh(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type TanH(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::TanH(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> TanH(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::TanH(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> TanH(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::TanH(x[0]), svtkm::TanH(x[1]), svtkm::TanH(x[2]), svtkm::TanH(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> TanH(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::TanH(x[0]), svtkm::TanH(x[1]), svtkm::TanH(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> TanH(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::TanH(x[0]),
                                                                         svtkm::TanH(x[1]));
}

/// Compute the hyperbolic arc sine of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 ASinH(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(asinh)(x);
#else
  return std::asinh(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 ASinH(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(asinh)(x);
#else
  return std::asinh(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type ASinH(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::ASinH(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> ASinH(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::ASinH(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> ASinH(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::ASinH(x[0]), svtkm::ASinH(x[1]), svtkm::ASinH(x[2]), svtkm::ASinH(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> ASinH(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::ASinH(x[0]), svtkm::ASinH(x[1]), svtkm::ASinH(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> ASinH(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::ASinH(x[0]),
                                                                         svtkm::ASinH(x[1]));
}

/// Compute the hyperbolic arc cosine of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 ACosH(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(acosh)(x);
#else
  return std::acosh(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 ACosH(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(acosh)(x);
#else
  return std::acosh(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type ACosH(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::ACosH(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> ACosH(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::ACosH(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> ACosH(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::ACosH(x[0]), svtkm::ACosH(x[1]), svtkm::ACosH(x[2]), svtkm::ACosH(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> ACosH(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::ACosH(x[0]), svtkm::ACosH(x[1]), svtkm::ACosH(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> ACosH(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::ACosH(x[0]),
                                                                         svtkm::ACosH(x[1]));
}

/// Compute the hyperbolic arc tangent of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 ATanH(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(atanh)(x);
#else
  return std::atanh(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 ATanH(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(atanh)(x);
#else
  return std::atanh(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type ATanH(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::ATanH(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> ATanH(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::ATanH(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> ATanH(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::ATanH(x[0]), svtkm::ATanH(x[1]), svtkm::ATanH(x[2]), svtkm::ATanH(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> ATanH(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::ATanH(x[0]), svtkm::ATanH(x[1]), svtkm::ATanH(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> ATanH(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::ATanH(x[0]),
                                                                         svtkm::ATanH(x[1]));
}

//-----------------------------------------------------------------------------
/// Computes \p x raised to the power of \p y.
///
static inline SVTKM_EXEC_CONT svtkm::Float32 Pow(svtkm::Float32 x, svtkm::Float32 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(pow)(x, y);
#else
  return std::pow(x, y);
#endif
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Pow(svtkm::Float64 x, svtkm::Float64 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(pow)(x, y);
#else
  return std::pow(x, y);
#endif
}

/// Compute the square root of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Sqrt(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(sqrt)(x);
#else
  return std::sqrt(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Sqrt(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(sqrt)(x);
#else
  return std::sqrt(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Sqrt(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Sqrt(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Sqrt(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Sqrt(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Sqrt(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Sqrt(x[0]), svtkm::Sqrt(x[1]), svtkm::Sqrt(x[2]), svtkm::Sqrt(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Sqrt(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Sqrt(x[0]), svtkm::Sqrt(x[1]), svtkm::Sqrt(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Sqrt(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Sqrt(x[0]),
                                                                         svtkm::Sqrt(x[1]));
}

/// Compute the reciprocal square root of \p x. The result of this function is
/// equivalent to <tt>1/Sqrt(x)</tt>. However, on some devices it is faster to
/// compute the reciprocal square root than the regular square root. Thus, you
/// should use this function whenever dividing by the square root.
///
#ifdef SVTKM_CUDA
static inline SVTKM_EXEC_CONT svtkm::Float32 RSqrt(svtkm::Float32 x)
{
  return rsqrtf(x);
}
static inline SVTKM_EXEC_CONT svtkm::Float64 RSqrt(svtkm::Float64 x)
{
  return rsqrt(x);
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Float64 RSqrt(T x)
{
  return rsqrt(static_cast<svtkm::Float64>(x));
}
#else  // !SVTKM_CUDA
static inline SVTKM_EXEC_CONT svtkm::Float32 RSqrt(svtkm::Float32 x)
{
  return 1 / svtkm::Sqrt(x);
}
static inline SVTKM_EXEC_CONT svtkm::Float64 RSqrt(svtkm::Float64 x)
{
  return 1 / svtkm::Sqrt(x);
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Float64 RSqrt(T x)
{
  return 1 / static_cast<svtkm::Float64>(x);
}
#endif // !SVTKM_CUDA

template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> RSqrt(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::RSqrt(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> RSqrt(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::RSqrt(x[0]), svtkm::RSqrt(x[1]), svtkm::RSqrt(x[2]), svtkm::RSqrt(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> RSqrt(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::RSqrt(x[0]), svtkm::RSqrt(x[1]), svtkm::RSqrt(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> RSqrt(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::RSqrt(x[0]),
                                                                         svtkm::RSqrt(x[1]));
}

/// Compute the cube root of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Cbrt(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(cbrt)(x);
#else
  return std::cbrt(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Cbrt(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(cbrt)(x);
#else
  return std::cbrt(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Cbrt(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Cbrt(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Cbrt(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Cbrt(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Cbrt(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Cbrt(x[0]), svtkm::Cbrt(x[1]), svtkm::Cbrt(x[2]), svtkm::Cbrt(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Cbrt(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Cbrt(x[0]), svtkm::Cbrt(x[1]), svtkm::Cbrt(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Cbrt(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Cbrt(x[0]),
                                                                         svtkm::Cbrt(x[1]));
}

/// Compute the reciprocal cube root of \p x. The result of this function is
/// equivalent to <tt>1/Cbrt(x)</tt>. However, on some devices it is faster to
/// compute the reciprocal cube root than the regular cube root. Thus, you
/// should use this function whenever dividing by the cube root.
///
#ifdef SVTKM_CUDA
static inline SVTKM_EXEC_CONT svtkm::Float32 RCbrt(svtkm::Float32 x)
{
  return rcbrtf(x);
}
static inline SVTKM_EXEC_CONT svtkm::Float64 RCbrt(svtkm::Float64 x)
{
  return rcbrt(x);
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Float64 RCbrt(T x)
{
  return rcbrt(static_cast<svtkm::Float64>(x));
}
#else  // !SVTKM_CUDA
static inline SVTKM_EXEC_CONT svtkm::Float32 RCbrt(svtkm::Float32 x)
{
  return 1 / svtkm::Cbrt(x);
}
static inline SVTKM_EXEC_CONT svtkm::Float64 RCbrt(svtkm::Float64 x)
{
  return 1 / svtkm::Cbrt(x);
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Float64 RCbrt(T x)
{
  return 1 / svtkm::Cbrt(static_cast<svtkm::Float64>(x));
}
#endif // !SVTKM_CUDA

template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> RCbrt(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::RCbrt(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> RCbrt(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::RCbrt(x[0]), svtkm::RCbrt(x[1]), svtkm::RCbrt(x[2]), svtkm::RCbrt(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> RCbrt(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::RCbrt(x[0]), svtkm::RCbrt(x[1]), svtkm::RCbrt(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> RCbrt(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::RCbrt(x[0]),
                                                                         svtkm::RCbrt(x[1]));
}

/// Computes e**\p x, the base-e exponential of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Exp(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(exp)(x);
#else
  return std::exp(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Exp(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(exp)(x);
#else
  return std::exp(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Exp(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Exp(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Exp(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Exp(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Exp(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Exp(x[0]), svtkm::Exp(x[1]), svtkm::Exp(x[2]), svtkm::Exp(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Exp(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Exp(x[0]), svtkm::Exp(x[1]), svtkm::Exp(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Exp(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Exp(x[0]),
                                                                         svtkm::Exp(x[1]));
}

/// Computes 2**\p x, the base-2 exponential of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Exp2(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(exp2)(x);
#else
  return std::exp2(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Exp2(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(exp2)(x);
#else
  return std::exp2(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Exp2(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Exp2(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Exp2(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Exp2(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Exp2(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Exp2(x[0]), svtkm::Exp2(x[1]), svtkm::Exp2(x[2]), svtkm::Exp2(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Exp2(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Exp2(x[0]), svtkm::Exp2(x[1]), svtkm::Exp2(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Exp2(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Exp2(x[0]),
                                                                         svtkm::Exp2(x[1]));
}

/// Computes (e**\p x) - 1, the of base-e exponental of \p x then minus 1. The
/// accuracy of this function is good even for very small values of x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 ExpM1(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(expm1)(x);
#else
  return std::expm1(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 ExpM1(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(expm1)(x);
#else
  return std::expm1(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type ExpM1(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::ExpM1(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> ExpM1(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::ExpM1(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> ExpM1(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::ExpM1(x[0]), svtkm::ExpM1(x[1]), svtkm::ExpM1(x[2]), svtkm::ExpM1(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> ExpM1(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::ExpM1(x[0]), svtkm::ExpM1(x[1]), svtkm::ExpM1(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> ExpM1(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::ExpM1(x[0]),
                                                                         svtkm::ExpM1(x[1]));
}

/// Computes 10**\p x, the base-10 exponential of \p x.
///
#ifdef SVTKM_CUDA
static inline SVTKM_EXEC_CONT svtkm::Float32 Exp10(svtkm::Float32 x)
{
  return exp10f(x);
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Exp10(svtkm::Float64 x)
{
  return exp10(x);
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Float64 Exp10(T x)
{
  return exp10(static_cast<svtkm::Float64>(x));
}
#else  // !SVTKM_CUDA
static inline SVTKM_EXEC_CONT svtkm::Float32 Exp10(svtkm::Float32 x)
{
  return svtkm::Pow(10, x);
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Exp10(svtkm::Float64 x)
{
  return svtkm::Pow(10, x);
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Float64 Exp10(T x)
{
  return svtkm::Pow(10, static_cast<svtkm::Float64>(x));
}
#endif // !SVTKM_CUDA

template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Exp10(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Exp10(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Exp10(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Exp10(x[0]), svtkm::Exp10(x[1]), svtkm::Exp10(x[2]), svtkm::Exp10(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Exp10(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Exp10(x[0]), svtkm::Exp10(x[1]), svtkm::Exp10(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Exp10(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Exp10(x[0]),
                                                                         svtkm::Exp10(x[1]));
}

/// Computes the natural logarithm of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Log(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(log)(x);
#else
  return std::log(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Log(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(log)(x);
#else
  return std::log(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Log(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Log(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Log(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Log(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Log(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Log(x[0]), svtkm::Log(x[1]), svtkm::Log(x[2]), svtkm::Log(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Log(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Log(x[0]), svtkm::Log(x[1]), svtkm::Log(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Log(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Log(x[0]),
                                                                         svtkm::Log(x[1]));
}

/// Computes the logarithm base 2 of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Log2(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(log2)(x);
#else
  return std::log2(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Log2(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(log2)(x);
#else
  return std::log2(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Log2(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Log2(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Log2(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Log2(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Log2(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Log2(x[0]), svtkm::Log2(x[1]), svtkm::Log2(x[2]), svtkm::Log2(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Log2(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Log2(x[0]), svtkm::Log2(x[1]), svtkm::Log2(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Log2(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Log2(x[0]),
                                                                         svtkm::Log2(x[1]));
}

/// Computes the logarithm base 10 of \p x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Log10(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(log10)(x);
#else
  return std::log10(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Log10(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(log10)(x);
#else
  return std::log10(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Log10(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Log10(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Log10(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Log10(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Log10(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Log10(x[0]), svtkm::Log10(x[1]), svtkm::Log10(x[2]), svtkm::Log10(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Log10(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Log10(x[0]), svtkm::Log10(x[1]), svtkm::Log10(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Log10(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Log10(x[0]),
                                                                         svtkm::Log10(x[1]));
}

/// Computes the value of log(1+x) accurately for very small values of x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Log1P(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(log1p)(x);
#else
  return std::log1p(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Log1P(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(log1p)(x);
#else
  return std::log1p(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Log1P(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Log1P(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Log1P(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Log1P(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Log1P(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Log1P(x[0]), svtkm::Log1P(x[1]), svtkm::Log1P(x[2]), svtkm::Log1P(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Log1P(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Log1P(x[0]), svtkm::Log1P(x[1]), svtkm::Log1P(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Log1P(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Log1P(x[0]),
                                                                         svtkm::Log1P(x[1]));
}

//-----------------------------------------------------------------------------
/// Returns \p x or \p y, whichever is larger.
///
template <typename T>
static inline SVTKM_EXEC_CONT T Max(const T& x, const T& y);
#ifdef SVTKM_USE_STL
static inline SVTKM_EXEC_CONT svtkm::Float32 Max(svtkm::Float32 x, svtkm::Float32 y)
{
  return (std::max)(x, y);
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Max(svtkm::Float64 x, svtkm::Float64 y)
{
  return (std::max)(x, y);
}
#else // !SVTKM_USE_STL
static inline SVTKM_EXEC_CONT svtkm::Float32 Max(svtkm::Float32 x, svtkm::Float32 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(fmax)(x, y);
#else
  return std::fmax(x, y);
#endif
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Max(svtkm::Float64 x, svtkm::Float64 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(fmax)(x, y);
#else
  return std::fmax(x, y);
#endif
}
#endif // !SVTKM_USE_STL

/// Returns \p x or \p y, whichever is smaller.
///
template <typename T>
static inline SVTKM_EXEC_CONT T Min(const T& x, const T& y);
#ifdef SVTKM_USE_STL
static inline SVTKM_EXEC_CONT svtkm::Float32 Min(svtkm::Float32 x, svtkm::Float32 y)
{
  return (std::min)(x, y);
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Min(svtkm::Float64 x, svtkm::Float64 y)
{
  return (std::min)(x, y);
}
#else // !SVTKM_USE_STL
static inline SVTKM_EXEC_CONT svtkm::Float32 Min(svtkm::Float32 x, svtkm::Float32 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(fmin)(x, y);
#else
  return std::fmin(x, y);
#endif
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Min(svtkm::Float64 x, svtkm::Float64 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(fmin)(x, y);
#else
  return std::fmin(x, y);
#endif
}
#endif // !SVTKM_USE_STL

namespace detail
{

template <typename T>
static inline SVTKM_EXEC_CONT T Max(T x, T y, svtkm::TypeTraitsScalarTag)
{
  return (x < y) ? y : x;
}

template <typename T>
static inline SVTKM_EXEC_CONT T Max(const T& x, const T& y, svtkm::TypeTraitsVectorTag)
{
  using Traits = svtkm::VecTraits<T>;
  T result;
  for (svtkm::IdComponent index = 0; index < Traits::NUM_COMPONENTS; index++)
  {
    Traits::SetComponent(
      result, index, svtkm::Max(Traits::GetComponent(x, index), Traits::GetComponent(y, index)));
  }
  return result;
}

template <typename T>
static inline SVTKM_EXEC_CONT T Min(T x, T y, svtkm::TypeTraitsScalarTag)
{
  return (x < y) ? x : y;
}

template <typename T>
static inline SVTKM_EXEC_CONT T Min(const T& x, const T& y, svtkm::TypeTraitsVectorTag)
{
  using Traits = svtkm::VecTraits<T>;
  T result;
  for (svtkm::IdComponent index = 0; index < Traits::NUM_COMPONENTS; index++)
  {
    Traits::SetComponent(
      result, index, svtkm::Min(Traits::GetComponent(x, index), Traits::GetComponent(y, index)));
  }
  return result;
}

} // namespace detail

/// Returns \p x or \p y, whichever is larger.
///
template <typename T>
static inline SVTKM_EXEC_CONT T Max(const T& x, const T& y)
{
  return detail::Max(x, y, typename svtkm::TypeTraits<T>::DimensionalityTag());
}

/// Returns \p x or \p y, whichever is smaller.
///
template <typename T>
static inline SVTKM_EXEC_CONT T Min(const T& x, const T& y)
{
  return detail::Min(x, y, typename svtkm::TypeTraits<T>::DimensionalityTag());
}

/// Clamp \p x to the given range.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Clamp(svtkm::Float32 x, svtkm::Float32 lo, svtkm::Float32 hi)
{
  return x > lo ? (x < hi ? x : hi) : lo;
}

inline SVTKM_EXEC_CONT svtkm::Float64 Clamp(svtkm::Float64 x, svtkm::Float64 lo, svtkm::Float64 hi)
{
  return x > lo ? (x < hi ? x : hi) : lo;
}
//-----------------------------------------------------------------------------

//#ifdef SVTKM_CUDA
#define SVTKM_USE_IEEE_NONFINITE
//#endif

#ifdef SVTKM_USE_IEEE_NONFINITE

namespace detail
{

union IEEE754Bits32 {
  svtkm::UInt32 bits;
  svtkm::Float32 scalar;
};
#define SVTKM_NAN_BITS_32 0x7FC00000U
#define SVTKM_INF_BITS_32 0x7F800000U
#define SVTKM_NEG_INF_BITS_32 0xFF800000U
#define SVTKM_EPSILON_32 1e-5f

union IEEE754Bits64 {
  svtkm::UInt64 bits;
  svtkm::Float64 scalar;
};
#define SVTKM_NAN_BITS_64 0x7FF8000000000000ULL
#define SVTKM_INF_BITS_64 0x7FF0000000000000ULL
#define SVTKM_NEG_INF_BITS_64 0xFFF0000000000000ULL
#define SVTKM_EPSILON_64 1e-9

template <typename T>
struct FloatLimits;

template <>
struct FloatLimits<svtkm::Float32>
{
  using BitsType = svtkm::detail::IEEE754Bits32;

  SVTKM_EXEC_CONT
  static svtkm::Float32 Nan()
  {
    BitsType nan = { SVTKM_NAN_BITS_32 };
    return nan.scalar;
  }

  SVTKM_EXEC_CONT
  static svtkm::Float32 Infinity()
  {
    BitsType inf = { SVTKM_INF_BITS_32 };
    return inf.scalar;
  }

  SVTKM_EXEC_CONT
  static svtkm::Float32 NegativeInfinity()
  {
    BitsType neginf = { SVTKM_NEG_INF_BITS_32 };
    return neginf.scalar;
  }

  SVTKM_EXEC_CONT
  static svtkm::Float32 Epsilon() { return SVTKM_EPSILON_32; }
};

template <int N>
struct FloatLimits<svtkm::Vec<svtkm::Float32, N>>
{
  using BitsType = svtkm::detail::IEEE754Bits32;

  SVTKM_EXEC_CONT
  static svtkm::Vec<svtkm::Float32, N> Nan()
  {
    BitsType nan = { SVTKM_NAN_BITS_32 };
    return svtkm::Vec<svtkm::Float32, N>(nan.scalar);
  }

  SVTKM_EXEC_CONT
  static svtkm::Vec<svtkm::Float32, N> Infinity()
  {
    BitsType inf = { SVTKM_INF_BITS_32 };
    return svtkm::Vec<svtkm::Float32, N>(inf.scalar);
  }

  SVTKM_EXEC_CONT
  static svtkm::Vec<svtkm::Float32, N> NegativeInfinity()
  {
    BitsType neginf = { SVTKM_NEG_INF_BITS_32 };
    return svtkm::Vec<svtkm::Float32, N>(neginf.scalar);
  }

  SVTKM_EXEC_CONT
  static svtkm::Vec<svtkm::Float32, N> Epsilon()
  {
    return svtkm::Vec<svtkm::Float32, N>(SVTKM_EPSILON_32);
  }
};

template <>
struct FloatLimits<svtkm::Float64>
{
  using BitsType = svtkm::detail::IEEE754Bits64;

  SVTKM_EXEC_CONT
  static svtkm::Float64 Nan()
  {
    BitsType nan = { SVTKM_NAN_BITS_64 };
    return nan.scalar;
  }

  SVTKM_EXEC_CONT
  static svtkm::Float64 Infinity()
  {
    BitsType inf = { SVTKM_INF_BITS_64 };
    return inf.scalar;
  }

  SVTKM_EXEC_CONT
  static svtkm::Float64 NegativeInfinity()
  {
    BitsType neginf = { SVTKM_NEG_INF_BITS_64 };
    return neginf.scalar;
  }

  SVTKM_EXEC_CONT
  static svtkm::Float64 Epsilon() { return SVTKM_EPSILON_64; }
};

template <int N>
struct FloatLimits<svtkm::Vec<svtkm::Float64, N>>
{
  using BitsType = svtkm::detail::IEEE754Bits64;

  SVTKM_EXEC_CONT
  static svtkm::Vec<svtkm::Float64, N> Nan()
  {
    BitsType nan = { SVTKM_NAN_BITS_64 };
    return svtkm::Vec<svtkm::Float64, N>(nan.scalar);
  }

  SVTKM_EXEC_CONT
  static svtkm::Vec<svtkm::Float64, N> Infinity()
  {
    BitsType inf = { SVTKM_INF_BITS_64 };
    return svtkm::Vec<svtkm::Float64, N>(inf.scalar);
  }

  SVTKM_EXEC_CONT
  static svtkm::Vec<svtkm::Float64, N> NegativeInfinity()
  {
    BitsType neginf = { SVTKM_NEG_INF_BITS_64 };
    return svtkm::Vec<svtkm::Float64, N>(neginf.scalar);
  }

  SVTKM_EXEC_CONT
  static svtkm::Vec<svtkm::Float64, N> Epsilon()
  {
    return svtkm::Vec<svtkm::Float64, N>(SVTKM_EPSILON_64);
  }
};

#undef SVTKM_NAN_BITS_32
#undef SVTKM_INF_BITS_32
#undef SVTKM_NEG_INF_BITS_32
#undef SVTKM_EPSILON_32
#undef SVTKM_NAN_BITS_64
#undef SVTKM_INF_BITS_64
#undef SVTKM_NEG_INF_BITS_64
#undef SVTKM_EPSILON_64

} // namespace detail

/// Returns the representation for not-a-number (NaN).
///
template <typename T>
static inline SVTKM_EXEC_CONT T Nan()
{
  return detail::FloatLimits<T>::Nan();
}

/// Returns the representation for infinity.
///
template <typename T>
static inline SVTKM_EXEC_CONT T Infinity()
{
  return detail::FloatLimits<T>::Infinity();
}

/// Returns the representation for negative infinity.
///
template <typename T>
static inline SVTKM_EXEC_CONT T NegativeInfinity()
{
  return detail::FloatLimits<T>::NegativeInfinity();
}

/// Returns the difference between 1 and the least value greater than 1
/// that is representable.
///
template <typename T>
static inline SVTKM_EXEC_CONT T Epsilon()
{
  return detail::FloatLimits<T>::Epsilon();
}

#else  // !SVTKM_USE_IEEE_NONFINITE

/// Returns the representation for not-a-number (NaN).
///
template <typename T>
static inline SVTKM_EXEC_CONT T Nan()
{
  return std::numeric_limits<T>::quiet_NaN();
}

/// Returns the representation for infinity.
///
template <typename T>
static inline SVTKM_EXEC_CONT T Infinity()
{
  return std::numeric_limits<T>::infinity();
}

/// Returns the representation for negative infinity.
///
template <typename T>
static inline SVTKM_EXEC_CONT T NegativeInfinity()
{
  return -std::numeric_limits<T>::infinity();
}

/// Returns the difference between 1 and the least value greater than 1
/// that is representable.
///
template <typename T>
static inline SVTKM_EXEC_CONT T Epsilon()
{
  return std::numeric_limits<T>::epsilon();
}
#endif // !SVTKM_USE_IEEE_NONFINITE

/// Returns the representation for not-a-number (NaN).
///
static inline SVTKM_EXEC_CONT svtkm::Float32 Nan32()
{
  return svtkm::Nan<svtkm::Float32>();
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Nan64()
{
  return svtkm::Nan<svtkm::Float64>();
}

/// Returns the representation for infinity.
///
static inline SVTKM_EXEC_CONT svtkm::Float32 Infinity32()
{
  return svtkm::Infinity<svtkm::Float32>();
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Infinity64()
{
  return svtkm::Infinity<svtkm::Float64>();
}

/// Returns the representation for negative infinity.
///
static inline SVTKM_EXEC_CONT svtkm::Float32 NegativeInfinity32()
{
  return svtkm::NegativeInfinity<svtkm::Float32>();
}
static inline SVTKM_EXEC_CONT svtkm::Float64 NegativeInfinity64()
{
  return svtkm::NegativeInfinity<svtkm::Float64>();
}

/// Returns the difference between 1 and the least value greater than 1
/// that is representable.
///
static inline SVTKM_EXEC_CONT svtkm::Float32 Epsilon32()
{
  return svtkm::Epsilon<svtkm::Float32>();
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Epsilon64()
{
  return svtkm::Epsilon<svtkm::Float64>();
}

//-----------------------------------------------------------------------------
/// Returns true if \p x is not a number.
///
template <typename T>
static inline SVTKM_EXEC_CONT bool IsNan(T x)
{
#ifndef SVTKM_CUDA
  using std::isnan;
#endif
  return (isnan(x) != 0);
}

/// Returns true if \p x is positive or negative infinity.
///
template <typename T>
static inline SVTKM_EXEC_CONT bool IsInf(T x)
{
#ifndef SVTKM_CUDA
  using std::isinf;
#endif
  return (isinf(x) != 0);
}

/// Returns true if \p x is a normal number (not NaN or infinite).
///
template <typename T>
static inline SVTKM_EXEC_CONT bool IsFinite(T x)
{
#ifndef SVTKM_CUDA
  using std::isfinite;
#endif
  return (isfinite(x) != 0);
}

//-----------------------------------------------------------------------------
/// Round \p x to the smallest integer value not less than x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Ceil(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(ceil)(x);
#else
  return std::ceil(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Ceil(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(ceil)(x);
#else
  return std::ceil(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Ceil(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Ceil(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Ceil(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Ceil(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Ceil(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Ceil(x[0]), svtkm::Ceil(x[1]), svtkm::Ceil(x[2]), svtkm::Ceil(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Ceil(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Ceil(x[0]), svtkm::Ceil(x[1]), svtkm::Ceil(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Ceil(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Ceil(x[0]),
                                                                         svtkm::Ceil(x[1]));
}

/// Round \p x to the largest integer value not greater than x.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Floor(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(floor)(x);
#else
  return std::floor(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Floor(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(floor)(x);
#else
  return std::floor(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Floor(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Floor(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Floor(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Floor(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Floor(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Floor(x[0]), svtkm::Floor(x[1]), svtkm::Floor(x[2]), svtkm::Floor(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Floor(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Floor(x[0]), svtkm::Floor(x[1]), svtkm::Floor(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Floor(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Floor(x[0]),
                                                                         svtkm::Floor(x[1]));
}

/// Round \p x to the nearest integral value.
///

inline SVTKM_EXEC_CONT svtkm::Float32 Round(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(round)(x);
#else
  return std::round(x);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Round(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(round)(x);
#else
  return std::round(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Round(const T& x)
{
  using RT = typename detail::FloatingPointReturnType<T>::Type;
  return svtkm::Round(static_cast<RT>(x));
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> Round(
  const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Round(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4> Round(
  const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 4>(
    svtkm::Round(x[0]), svtkm::Round(x[1]), svtkm::Round(x[2]), svtkm::Round(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3> Round(
  const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 3>(
    svtkm::Round(x[0]), svtkm::Round(x[1]), svtkm::Round(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2> Round(
  const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<typename detail::FloatingPointReturnType<T>::Type, 2>(svtkm::Round(x[0]),
                                                                         svtkm::Round(x[1]));
}

//-----------------------------------------------------------------------------
/// Computes the remainder on division of 2 floating point numbers. The return
/// value is \p numerator - n \p denominator, where n is the quotient of \p
/// numerator divided by \p denominator rounded towards zero to an integer. For
/// example, <tt>FMod(6.5, 2.3)</tt> returns 1.9, which is 6.5 - 2*2.3.
///
static inline SVTKM_EXEC_CONT svtkm::Float32 FMod(svtkm::Float32 x, svtkm::Float32 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(fmod)(x, y);
#else
  return std::fmod(x, y);
#endif
}
static inline SVTKM_EXEC_CONT svtkm::Float64 FMod(svtkm::Float64 x, svtkm::Float64 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(fmod)(x, y);
#else
  return std::fmod(x, y);
#endif
}

/// Computes the remainder on division of 2 floating point numbers. The return
/// value is \p numerator - n \p denominator, where n is the quotient of \p
/// numerator divided by \p denominator rounded towards the nearest integer
/// (instead of toward zero like FMod). For example, <tt>FMod(6.5, 2.3)</tt>
/// returns -0.4, which is 6.5 - 3*2.3.
///
#ifdef SVTKM_MSVC
template <typename T>
static inline SVTKM_EXEC_CONT T Remainder(T numerator, T denominator)
{
  T quotient = svtkm::Round(numerator / denominator);
  return numerator - quotient * denominator;
}
#else // !SVTKM_MSVC
static inline SVTKM_EXEC_CONT svtkm::Float32 Remainder(svtkm::Float32 x, svtkm::Float32 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(remainder)(x, y);
#else
  return std::remainder(x, y);
#endif
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Remainder(svtkm::Float64 x, svtkm::Float64 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(remainder)(x, y);
#else
  return std::remainder(x, y);
#endif
}
#endif // !SVTKM_MSVC

/// Returns the remainder on division of 2 floating point numbers just like
/// Remainder. In addition, this function also returns the \c quotient used to
/// get that remainder.
///
template <typename QType>
static inline SVTKM_EXEC_CONT svtkm::Float32 RemainderQuotient(svtkm::Float32 numerator,
                                                             svtkm::Float32 denominator,
                                                             QType& quotient)
{
  int iQuotient;
#ifdef SVTKM_CUDA
  const svtkm::Float32 result =
    SVTKM_CUDA_MATH_FUNCTION_32(remquo)(numerator, denominator, &iQuotient);
#else
  const svtkm::Float32 result = std::remquo(numerator, denominator, &iQuotient);
#endif
  quotient = static_cast<QType>(iQuotient);
  return result;
}
template <typename QType>
static inline SVTKM_EXEC_CONT svtkm::Float64 RemainderQuotient(svtkm::Float64 numerator,
                                                             svtkm::Float64 denominator,
                                                             QType& quotient)
{
  int iQuotient;
#ifdef SVTKM_CUDA
  const svtkm::Float64 result =
    SVTKM_CUDA_MATH_FUNCTION_64(remquo)(numerator, denominator, &iQuotient);
#else
  const svtkm::Float64 result = std::remquo(numerator, denominator, &iQuotient);
#endif
  quotient = static_cast<QType>(iQuotient);
  return result;
}

/// Gets the integral and fractional parts of \c x. The return value is the
/// fractional part and \c integral is set to the integral part.
///
static inline SVTKM_EXEC_CONT svtkm::Float32 ModF(svtkm::Float32 x, svtkm::Float32& integral)
{
  return std::modf(x, &integral);
}
static inline SVTKM_EXEC_CONT svtkm::Float64 ModF(svtkm::Float64 x, svtkm::Float64& integral)
{
  return std::modf(x, &integral);
}

//-----------------------------------------------------------------------------
/// Return the absolute value of \p x. That is, return \p x if it is positive or
/// \p -x if it is negative.
///
static inline SVTKM_EXEC_CONT svtkm::Int32 Abs(svtkm::Int32 x)
{
  return abs(x);
}
static inline SVTKM_EXEC_CONT svtkm::Int64 Abs(svtkm::Int64 x)
{
#if SVTKM_SIZE_LONG == 8
  return labs(x);
#elif SVTKM_SIZE_LONG_LONG == 8
  return llabs(x);
#else
#error Unknown size of Int64.
#endif
}
static inline SVTKM_EXEC_CONT svtkm::Float32 Abs(svtkm::Float32 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(fabs)(x);
#else
  return std::fabs(x);
#endif
}
static inline SVTKM_EXEC_CONT svtkm::Float64 Abs(svtkm::Float64 x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(fabs)(x);
#else
  return std::fabs(x);
#endif
}
template <typename T>
static inline SVTKM_EXEC_CONT typename detail::FloatingPointReturnType<T>::Type Abs(T x)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(fabs)(static_cast<svtkm::Float64>(x));
#else
  return std::fabs(static_cast<svtkm::Float64>(x));
#endif
}
template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<T, N> Abs(const svtkm::Vec<T, N>& x)
{
  svtkm::Vec<T, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::Abs(x[index]);
  }
  return result;
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<T, 4> Abs(const svtkm::Vec<T, 4>& x)
{
  return svtkm::Vec<T, 4>(svtkm::Abs(x[0]), svtkm::Abs(x[1]), svtkm::Abs(x[2]), svtkm::Abs(x[3]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<T, 3> Abs(const svtkm::Vec<T, 3>& x)
{
  return svtkm::Vec<T, 3>(svtkm::Abs(x[0]), svtkm::Abs(x[1]), svtkm::Abs(x[2]));
}
template <typename T>
static inline SVTKM_EXEC_CONT svtkm::Vec<T, 2> Abs(const svtkm::Vec<T, 2>& x)
{
  return svtkm::Vec<T, 2>(svtkm::Abs(x[0]), svtkm::Abs(x[1]));
}

/// Returns a nonzero value if \p x is negative.
///
static inline SVTKM_EXEC_CONT svtkm::Int32 SignBit(svtkm::Float32 x)
{
#ifndef SVTKM_CUDA
  using std::signbit;
#endif
  return static_cast<svtkm::Int32>(signbit(x));
}
static inline SVTKM_EXEC_CONT svtkm::Int32 SignBit(svtkm::Float64 x)
{
#ifndef SVTKM_CUDA
  using std::signbit;
#endif
  return static_cast<svtkm::Int32>(signbit(x));
}

/// Returns true if \p x is less than zero, false otherwise.
///
static inline SVTKM_EXEC_CONT bool IsNegative(svtkm::Float32 x)
{
  return (svtkm::SignBit(x) != 0);
}
static inline SVTKM_EXEC_CONT bool IsNegative(svtkm::Float64 x)
{
  return (svtkm::SignBit(x) != 0);
}

/// Copies the sign of \p y onto \p x.  If \p y is positive, returns Abs(\p x).
/// If \p y is negative, returns -Abs(\p x).
///
static inline SVTKM_EXEC_CONT svtkm::Float32 CopySign(svtkm::Float32 x, svtkm::Float32 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(copysign)(x, y);
#else
  return std::copysign(x, y);
#endif
}
static inline SVTKM_EXEC_CONT svtkm::Float64 CopySign(svtkm::Float64 x, svtkm::Float64 y)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(copysign)(x, y);
#else
  return std::copysign(x, y);
#endif
}

template <typename T, svtkm::IdComponent N>
static inline SVTKM_EXEC_CONT svtkm::Vec<T, N> CopySign(const svtkm::Vec<T, N>& x,
                                                      const svtkm::Vec<T, N>& y)
{
  svtkm::Vec<T, N> result;
  for (svtkm::IdComponent index = 0; index < N; index++)
  {
    result[index] = svtkm::CopySign(x[index], y[index]);
  }
  return result;
}

/// Decompose floating poing value
///

inline SVTKM_EXEC_CONT svtkm::Float32 Frexp(svtkm::Float32 x, svtkm::Int32 *exponent)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(frexp)(x, exponent);
#else
  return std::frexp(x, exponent);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Frexp(svtkm::Float64 x, svtkm::Int32 *exponent)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(frexp)(x, exponent);
#else
  return std::frexp(x, exponent);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float32 Ldexp(svtkm::Float32 x, svtkm::Int32 exponent)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_32(ldexp)(x, exponent);
#else
  return std::ldexp(x, exponent);
#endif
}

inline SVTKM_EXEC_CONT svtkm::Float64 Ldexp(svtkm::Float64 x, svtkm::Int32 exponent)
{
#ifdef SVTKM_CUDA
  return SVTKM_CUDA_MATH_FUNCTION_64(ldexp)(x, exponent);
#else
  return std::ldexp(x, exponent);
#endif
}

/// Bitwise operations
///

/// Find the first set bit in @a word, and return its position (1-32). If no
/// bits are set, returns 0.
#ifdef SVTKM_CUDA_DEVICE_PASS
// Need to explicitly mark this as __device__ since __ffs is device only.
inline __device__
svtkm::Int32 FindFirstSetBit(svtkm::UInt32 word)
{
  // Output is [0,32], with ffs(0) == 0
  return __ffs(static_cast<int>(word));
}
#else // CUDA_DEVICE_PASS
inline SVTKM_EXEC_CONT
svtkm::Int32 FindFirstSetBit(svtkm::UInt32 word)
{
#  if defined(SVTKM_GCC) || defined(SVTKM_CLANG)

  // Output is [0,32], with ffs(0) == 0
  return __builtin_ffs(static_cast<int>(word));

#  elif defined(SVTKM_MSVC)

  // Output is [0, 31], check return code to see if bits are set:
  svtkm::UInt32 firstSet;
  return _BitScanForward(reinterpret_cast<DWORD*>(&firstSet), word) != 0
         ? static_cast<svtkm::Int32>(firstSet + 1) : 0;

#  elif defined(SVTKM_ICC)

  // Output is [0, 31], undefined if word is 0.
  return word != 0 ? _bit_scan_forward(word) + 1 : 0;

#  else

  // Naive implementation:
  if (word == 0)
  {
    return 0;
  }

  svtkm::Int32 bit = 1;
  while ((word & 0x1) == 0)
  {
    word >>= 1;
    ++bit;
  }
  return bit;

#  endif
}
#endif // CUDA_DEVICE_PASS

/// Find the first set bit in @a word, and return its position (1-64). If no
/// bits are set, returns 0.
#ifdef SVTKM_CUDA_DEVICE_PASS
// Need to explicitly mark this as __device__ since __ffsll is device only.
inline __device__
svtkm::Int32 FindFirstSetBit(svtkm::UInt64 word)
{

  // Output is [0,64], with ffs(0) == 0
  return __ffsll(static_cast<long long int>(word));
}
#else // CUDA_DEVICE_PASS
inline SVTKM_EXEC_CONT
svtkm::Int32 FindFirstSetBit(svtkm::UInt64 word)
{
#  if defined(SVTKM_GCC) || defined(SVTKM_CLANG) || defined(SVTKM_ICC)

  // Output is [0,64], with ffs(0) == 0
  return __builtin_ffsll(static_cast<long long int>(word));

#  elif defined(SVTKM_MSVC)

  // Output is [0, 63], check return code to see if bits are set:
  svtkm::UInt32 firstSet;
  return _BitScanForward64(reinterpret_cast<DWORD*>(&firstSet), word) != 0
         ? static_cast<svtkm::Int32>(firstSet + 1) : 0;

#  else

  // Naive implementation:
  if (word == 0)
  {
    return 0;
  }

  svtkm::Int32 bit = 1;
  while ((word & 0x1) == 0)
  {
    word >>= 1;
    ++bit;
  }
  return bit;

#  endif
}
#endif // CUDA_DEVICE_PASS

/// Count the total number of bits set in @a word.
#ifdef SVTKM_CUDA_DEVICE_PASS
// Need to explicitly mark this as __device__ since __popc is device only.
inline __device__
svtkm::Int32 CountSetBits(svtkm::UInt32 word)
{
  return __popc(word);
}
#else // CUDA_DEVICE_PASS
inline SVTKM_EXEC_CONT
svtkm::Int32 CountSetBits(svtkm::UInt32 word)
{
#  if defined(SVTKM_GCC) || defined(SVTKM_CLANG)

  return __builtin_popcount(word);

#  elif defined(SVTKM_MSVC)

  return static_cast<svtkm::Int32>(__popcnt(word));

#  elif defined(SVTKM_ICC)

  return _popcnt32(static_cast<int>(word));

#  else

  // Naive implementation:
  svtkm::Int32 bits = 0;
  while (word)
  {
    if (word & 0x1)
    {
      ++bits;
    }
    word >>= 1;
  }
  return bits;

#  endif
}
#endif // CUDA_DEVICE_PASS

/// Count the total number of bits set in @a word.
#ifdef SVTKM_CUDA_DEVICE_PASS
// Need to explicitly mark this as __device__ since __popcll is device only.
inline __device__
svtkm::Int32 CountSetBits(svtkm::UInt64 word)
{
  return __popcll(word);
}
#else // CUDA_DEVICE_PASS
inline SVTKM_EXEC_CONT
svtkm::Int32 CountSetBits(svtkm::UInt64 word)
{
#  if defined(SVTKM_GCC) || defined(SVTKM_CLANG)

  return __builtin_popcountll(word);

#  elif defined(SVTKM_MSVC)

  return static_cast<svtkm::Int32>(__popcnt64(word));

#  elif defined(SVTKM_ICC)

  return _popcnt64(static_cast<svtkm::Int64>(word));

#  else

  // Naive implementation:
  svtkm::Int32 bits = 0;
  while (word)
  {
    if (word & 0x1)
    {
      ++bits;
    }
    word >>= 1;
  }
  return bits;

#  endif
}
#endif // CUDA_DEVICE_PASS

} // namespace svtkm
// clang-format on

#endif //svtk_m_Math_h
